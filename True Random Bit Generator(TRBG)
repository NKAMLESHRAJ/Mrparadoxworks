///////////////////////////////////////////////////////////////////////
//module test6_5(xor_out,ch_ena,clk,reset);
module test(trng_out,ch_ena,clk,reset);
input ch_ena,clk,reset;
wire ch_ena,clk;
 
wire d,ts1_out,ts2_out,s;
wire b1,b2;
wire xor_out,out;
output trng_out;
//wire a1,a2,a3,a4;
wire z;

chaos1 c(s,ch_ena,z);
ring1 r1(ts1_out,clk,s);
ring2 r2(ts2_out,clk,s);
xor(d,ts1_out,ts2_out);
ph_det1 ph(z,d,clk); 
//metastable  circuitm 
latch l1(b1,b2,ts1_out,ts2_out,clk);
xor (xor_out,b1,b2); 
//sipo sp(a1,a2,a3,a4,xor_out,clk,reset);
nand (out,xor_out,trng_out)
lfsr l(trng_out,out,reset)
endmodule

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//ring1
module ring1(ts1_out,clk,s);
input clk,s;
output ts1_out;
wire fg1,a1,a2,a3,a4,a5,a6,a7,s,t1_out;
assign a1=~(fg1 & clk); 
assign a2=~(s ^ clk ^ a1);
assign a3=~a2;
assign a4=~a3;
assign a5=~a4; 
assign t1_out=~a5;
assign a6=~t1_out;
assign a7=~a6;
assign ts1_out=~a7;
//mux1
assign fg1=s?ts1_out:t1_out;
endmodule


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//ring2//
module ring2(ts2_out,clk,s);
input clk,s;
output ts2_out;
wire fg2,a1,a2,a3,a4,a5,a6,a7,t2_out,s;
 
assign a1=~(fg2 & clk); 
assign a2=(s ^ a1);
assign a3=~a2;
assign a4=~a3;
assign a5=~a4; 
assign t2_out=~a5;
assign a6=~t2_out;
assign a7=~a6;
assign ts2_out=~a7;
//mux2
assign fg2=s?ts2_out:t2_out;
endmodule
////////////////////////////////////////////////////////////////////////////////////////////////////////


//phase detector

module ph_det1(q,d,clk);
output  q;
input clk;
input d;
reg q;

initial 
begin 
q=1'b0;
end

always @(posedge clk)
begin
q<=d;
end   

endmodule
/////////////////////////////////////////////////////////////////////////
//chaos circuit
module chaos1(s,ch_ena,q);
input q,ch_ena;
output s;
wire a4, a5;

assign a4=~ q;
assign a5=~ a4;
assign s=~(ch_ena & a5); 
endmodule

////////////////////////////////////////////////////////////////////////////////////////////
//latch
module latch(a1,a2,t1,t2,clk);
input t1,t2,clk;
output a1,a2;
reg a1,a2;

initial
begin
a1<=1'b0;
a2<=1'b1;
end

always @(posedge clk)
begin
 a1<=~(t1 & a2);
 a2<=~(t2 & a1);
end
endmodule

///////////////////////////////////////////////////////////////////////////////
///////sipo
//module sipo(a[0],a[1],a[2],a[3],xor_out,clk,reset);
//input xor_out,clk,reset;
//output [3:0]a;
//reg [3:0]a;
//
//always @(posedge clk)
//if(reset)
//begin
//a<=1'b0;
//end 
//else
//begin 
//a[3]<=xor_out;
//a[2]<=a[3];
//a[1]<=a[2];
//a[0]<=a[1];
//end
//endmodule 

/////////////////////////////////////////////////////////////////////////////////////
//lfsr
module lfsr (out, clk, rst);

  output reg [3:0] out;
  input clk, rst;

  wire feedback;

  assign feedback = ~(out[3] ^ out[2]);

always @(posedge clk, posedge rst)
  begin
    if (rst)
      out = 4'b0;
    else
      out = {out[2:0],feedback};
  end
endmodule

